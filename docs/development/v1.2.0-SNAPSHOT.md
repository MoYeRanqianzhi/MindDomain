# v1.2.0-SNAPSHOT — 空间替换、纯白渲染链、高度上限修复

> 基于 v1.1.0 开发，尚未正式发布

## 新增功能

### 1. 空间替换系统（V 键）

玩家在现实世界中按下 V 键，可将脚下区域的方块和实体与空间维度进行**双向交换**，实现空间内建筑的"现实化"。

**核心实现**：`swap/SpaceSwapManager.kt`（约 500 行）

**工作流程**：
1. 客户端发送 `SwapSpaceC2SPayload`
2. 服务端验证（玩家在现实世界、拥有空间、空间维度可用）
3. 异步预加载空间维度区块（带 `forceLoad` 标记），等待 3 tick 确保区块和实体从磁盘加载
4. 执行双向交换：
   - 快照现实世界区域的方块（含方块实体 NBT）
   - 快照空间维度对应区域的方块
   - 将空间快照写入现实世界，将现实快照写入空间
   - 交换两个区域内的非玩家实体（通过 `teleportTo` 跨维度传送）
5. 更新玩家位置和记忆坐标

**坐标映射**：
```
现实 → 空间：spaceX = realX - centerX, spaceY = (realY - baseY) + PLATFORM_Y + 1
空间 → 现实：realX = spaceX + centerX, realY = (spaceY - PLATFORM_Y - 1) + baseY
```

**技术细节**：
- 使用 `Block.NOTIFY_LISTENERS | FORCE_STATE | SKIP_DROPS | SKIP_BLOCK_ADDED_CALLBACK` 标记防止连锁掉落和验证错误
- 方块实体 NBT 完整保留（箱子内容、熔炉状态等）
- 垂直维度使用 `SpaceLevelConfig.getVerticalSize(size)` 受上限约束

**新增 Mixin**：`ServerWorldAccessor`（访问 `ServerWorld.entityManager`，用于异步实体加载）

---

### 2. 客户端纯白渲染链

v1.1.0 中空间内方块受方向光照和雾气影响呈偏灰色调。v1.2.0 通过三层 Mixin 构建纯白渲染链：

| 层级 | 实现 | 作用 |
|------|------|------|
| 方向光照 | `ClientWorldMixin.java` | `getBrightness()` 在空间内恒返回 `1.0f`，消除面方向亮度差异 |
| 雾气颜色 | `FogRendererMixin.java` | `getFogColor()` 在空间内强制返回纯白 `(1,1,1,1)` |
| 光照贴图 | `LightmapTextureManagerMixin.java` | `update()` 在空间内将 16x16 光照贴图填充为 `0xFFFFFFFF` |

**为什么需要三层**：
- 仅去除方向光照不够 — MC 对不同面方向施加不同亮度系数（顶面 1.0，底面 0.5，侧面 0.6-0.8）
- 仅白色雾气不够 — 渲染管线的颜色混合可能产生偏灰色调
- 仅白色光照贴图不够 — `core/lightmap` 着色器包含 `mix(color, vec3(0.75), 0.04)` 操作，始终偏向灰色

---

### 3. 空间高度上限修复

**问题**：空间尺寸 `size` 同时用于水平和垂直方向（正方体），当等级足够高时天花板位置超过维度最大高度 319。

**解决方案**（`SpaceLevelConfig.kt`）：

```kotlin
MAX_VERTICAL_SIZE = 1024          // 垂直高度上限
EXPANSION_PER_LEVEL_AFTER_CAP = 4 // 超过上限后每级水平扩展量（补偿）

fun getVerticalSize(size: Int) = min(size, MAX_VERTICAL_SIZE)
fun getExpansionPerLevel(currentSize: Int) = if (currentSize >= MAX_VERTICAL_SIZE) 4 else 2
```

**维度类型调整**：
- `mind_domain.json`：`height` 从 384 → **1168**，`logical_height` 同步
- `MindDomainChunkGenerator.getWorldHeight()` → **1168**

**数值推导**：
- 天花板 Y = `PLATFORM_Y(64) + 1024 + 1 = 1089`
- 所需高度 ≥ `1089 - (-64) = 1153` → 取 16 倍数 = **1168**
- 最高 Y = `-64 + 1168 = 1104`，满足 MC 约束 `≤ 2032`

**`DynamicWorldManager.expandSpace()` 变更**：
- `calculateBounds()` Y 轴使用 `getVerticalSize(size)` 而非 `size`
- 扩展增量使用 `getExpansionPerLevel(oldSize)` 计算（2 或 4）
- 处理跨越上限的过渡情况

---

## 新增文件

| 文件 | 说明 |
|------|------|
| `swap/SpaceSwapManager.kt` | 空间替换核心逻辑（~500 行） |
| `level/SpaceLevelConfig.kt` | 等级系统配置（升级公式、垂直上限、扩展参数） |
| `client/mixin/ClientWorldMixin.java` | 方向光照移除 |
| `client/mixin/FogRendererMixin.java` | 雾气颜色覆盖 |
| `client/mixin/LightmapTextureManagerMixin.java` | 光照贴图全白 |
| `mixin/ServerWorldAccessor.java` | ServerWorld 实体管理器访问 |

## 变更文件

| 文件 | 变更内容 |
|------|----------|
| `ModNetworking.kt` | 新增 `SwapSpaceC2SPayload` 及其处理逻辑 |
| `DynamicWorldManager.kt` | 新增 `expandSpace()`、`updateBoundaries()`、`syncWorldBorderToPlayers()`；`calculateBounds()` 引入垂直上限 |
| `MindDomainChunkGenerator.kt` | `getWorldHeight()` → 1168 |
| `mind_domain.json` | `height`/`logical_height` → 1168 |
| `ModKeyBindings.kt` | 新增 V 键（空间替换）绑定 |
| `MinddomainClient.kt` | 注册客户端 Mixin 渲染链 |
| `fabric.mod.json` | 新增客户端 Mixin 配置 |
| `minddomain.mixins.json` | 新增 `ServerWorldAccessor` |
| `minddomain.client.mixins.json` | 新增 `ClientWorldMixin`、`FogRendererMixin`、`LightmapTextureManagerMixin` |

## 已知问题

（无新增已知问题）

## 未来待办

### 生物群系染色纹理亮化（未解决）

**目标**：将草方块、树叶等的灰度基础纹理在空间内亮化为接近纯白，保持图案可识别。

**背景**：`grass_block_top.png` 等纹理是灰度图（像素值约 112-195/255），渲染公式为 `最终颜色 = 纹理像素 × 生物群系色调`。即使色调为纯白 (0xFFFFFF)，灰度纹理本身决定了输出仍为灰色。

**已尝试的技术方案**：

1. **运行时纹理图集像素替换**（`MindDomainTextureSwapper` + `SpriteContentsAccessor` Mixin）
   - 通过 Mixin `@Accessor` 暴露 `SpriteContents` 的 `image` 和 `mipmapLevelsImages` 私有字段
   - 在 `END_CLIENT_TICK` 中检测维度切换，使用 `NativeImage.setColorArgb()` 直接修改精灵的源像素数据
   - 同时通过 `CommandEncoder.writeToTexture()` 调用 `glTexSubImage2D` 将修改后的像素上传至 GPU 纹理图集
   - **结果**：NativeImage 修改成功（readback 验证通过），`writeToTexture` 无 GL 错误，但渲染结果无任何可见变化

2. **字节码级渲染管线分析**
   - 反编译了 `GlCommandEncoder.writeToTexture()`、`SpriteAtlasTexture.upload()/createTexture()`、`GlTexture`、`GlTextureView`、`GpuTexture`、`TextureFormat`、`NativeImage` 等核心类
   - 确认图集纹理使用 `RGBA8` 格式，`usage=15`（含 `COPY_DST`），非压缩格式
   - 确认 `writeToTexture` 内部通过 `GlStateManager._bindTexture()` + `_texSubImage2D()` 标准 OpenGL 调用上传
   - 确认所有 `GpuTextureView` 共享同一 `GlTexture` 底层 GL 存储
   - 确认 Minecraft 的图集上传使用 `RenderPass` + `ANIMATE_SPRITE_BLIT` 管线进行 Blit，而非直接 `writeToTexture`
   - **结论**：直接 `writeToTexture` 到图集纹理理论上应正确，但实际无效果；原因未明确，可能与 1.21.11 新渲染后端有关

3. **其他已排除方案**：夜视效果（影响全屏）、全屏叠加层（无法仅作用于方块）、全局纹理亮化（影响主世界）

**可能的后续方向**：
- 使用与 MC 相同的 Blit 管线（临时 `GpuTexture` → `writeToTexture` → `RenderPass` + `ANIMATE_SPRITE_BLIT` Blit 到图集 `mipTextures` 视图）
- 自定义 Core Shader 在片段着色器中对染色方块施加亮度提升
- 运行时资源包注入，在进入/离开维度时动态提供亮化纹理
- 通过 Mixin 拦截 BakedQuad 数据，在特定维度中替换纹理引用
