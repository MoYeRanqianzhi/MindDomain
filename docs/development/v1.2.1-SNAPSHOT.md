# v1.2.1-SNAPSHOT — 空间替换 Bug 修复

> 基于 v1.2.0-SNAPSHOT 开发，尚未正式发布

## 修复内容

### 1. 容器方块物品复制漏洞

**问题**：空间替换时，箱子、熔炉等容器方块的物品被复制——物品既以掉落物形式散落，又通过 NBT 恢复到新位置的容器中，可被利用无限刷物品。

**根因**：`writeBlockSnapshot()` 调用 `setBlockState()` 替换方块时，旧方块的 `onStateReplaced()` 被触发，容器方块在此回调中调用 `ItemScatterer.scatter()` 将物品栏内容以掉落物形式散落到世界中。但快照已完整保存了方块实体的 NBT 数据，新方块实体通过 NBT 恢复了相同的物品——导致一份物品变成两份。`SKIP_DROPS` 标志仅影响方块本身的战利品掉落，不影响 `onStateReplaced()` 中的物品栏散落逻辑。

**修复**：在 `writeBlockSnapshot()` 中，调用 `setBlockState()` 之前检查目标位置的现有方块实体是否实现 `Inventory` 接口，如果是则调用 `clear()` 清空物品栏。这样 `onStateReplaced()` 触发时物品栏已为空，不会产生掉落物。

```kotlin
val existingBlockEntity = world.getBlockEntity(pos)
if (existingBlockEntity is Inventory) {
    (existingBlockEntity as Inventory).clear()
}
world.setBlockState(pos, snapshot.blockState, SWAP_SET_BLOCK_FLAGS)
```

---

### 2. 睡眠实体消失与床状态损坏

**问题**：空间替换时，床上睡眠的实体（村民等）会消失，且床保持 `occupied=true` 状态无法使用。

**根因**：睡眠实体与床方块通过 `occupied` 属性双向绑定。方块替换阶段床被替换为其他方块时，睡眠实体失去关联的床方块，进入无效状态被引擎移除。同时快照捕获了 `occupied=true` 的床状态并写入新位置，但已无实体与之关联。

**修复**：在 `executeSwap()` 的快照阶段之前新增预处理阶段，调用 `wakeUpSleepingEntities()` 唤醒两侧交换区域内所有睡眠中的 `LivingEntity`。`LivingEntity.wakeUp()` 同时：
- 清除实体的睡眠位置引用
- 将床方块的 `occupied` 属性重置为 `false`

唤醒后快照自然捕获到 `occupied=false` 的床状态，实体也处于正常站立状态可安全传送。

```kotlin
// executeSwap() 预处理阶段
wakeUpSleepingEntities(realWorld, ...)
wakeUpSleepingEntities(spaceWorld, ...)

// 辅助方法：唤醒区域内所有睡眠实体
private fun wakeUpSleepingEntities(world, minX, minY, minZ, horizontalSize, verticalSize) {
    val sleepingEntities = world.getOtherEntities(null, box) {
        it is LivingEntity && it.isSleeping
    }
    for (entity in sleepingEntities) {
        (entity as LivingEntity).wakeUp()
    }
}
```

---

### 3. 多部件实体重复创建

**问题**：空间替换时，末影龙等多部件实体会出现多个副本。

**根因**：多部件实体（如末影龙）由一个主体实体和多个子部件实体（碰撞箱部件）组成。`getOtherEntities()` 会将主体和所有子部件作为独立实体返回。主体被 `teleportTo()` 后引擎在目标维度创建完整的新实体（含全部子部件），而每个子部件又被单独 `teleportTo()`，触发额外的实体创建，导致重复。

**修复**：新增 `filterOutSubParts()` 方法，利用 `Entity.isPartOf(Entity)` 通用检测子部件。该方法是 `Entity` 基类方法，默认实现仅对自身返回 `true`；多部件子实体重写此方法，对其主体也返回 `true`。通过交叉检查收集到的实体对，识别并排除所有子部件，仅传送主体。

此方案不依赖特定类型（如 `EnderDragonPart`），适用于原版和任何模组的多部件实体。

```kotlin
private fun filterOutSubParts(entities: List<Entity>): List<Entity> {
    val subParts = HashSet<Entity>()
    for (entity in entities) {
        for (other in entities) {
            if (entity !== other && entity.isPartOf(other)) {
                subParts.add(entity)
                break
            }
        }
    }
    return if (subParts.isEmpty()) entities else entities.filter { it !in subParts }
}
```

---

## 变更文件总览

| 文件 | 变更内容 |
|------|----------|
| `swap/SpaceSwapManager.kt` | 新增容器清空、睡眠实体唤醒、多部件子部件过滤三项修复 |
| `gradle.properties` | `mod_version` 1.2.0-SNAPSHOT → 1.2.1-SNAPSHOT |

## 已知问题

（无新增已知问题）
