# v1.3.0-SNAPSHOT — 模组 Logo 更新 & 死亡掉落 3D 空间球实体

> 基于 v1.2.1-SNAPSHOT 开发，尚未正式发布

## 新增功能

### 1. 模组 Logo 更新

替换 `src/main/resources/assets/minddomain/icon.png` 为新设计的模组图标，提升在模组加载器列表中的辨识度。

---

### 2. 死亡掉落 3D 空间球实体（SpaceBallEntity）

玩家死亡后不再以普通掉落物（ItemEntity）形式掉落空间球，而是在死亡位置生成自定义实体 `SpaceBallEntity`，以大型浮动 3D 球体形态呈现，便于玩家在复杂地形中快速定位和回收。

**实体行为**（`entity/SpaceBallEntity.kt`）：

| 属性 | 说明 |
|------|------|
| 无敌 | `isInvulnerable = true`，不受任何伤害 |
| 发光描边 | `setGlowing(true)`，始终带高亮轮廓，可透过方块看到 |
| 重力下落 | 生成后自然下落直到接触地面 |
| 视觉浮动 | 落地后由渲染器实现正弦浮动动画（不改变服务端位置） |
| 右键拾取 | 玩家右键交互将空间球物品放入背包 |
| 持久化 | NBT 序列化 ItemStack / landed / age，服务器重启后存在 |
| DataTracker | 同步 ItemStack 到客户端供渲染器使用 |

**五层粒子特效**（客户端，每 tick 执行）：

1. **三轴轨道环**：三条不同平面的 `END_ROD` 粒子圆形轨道（XZ / XY / YZ），角速度各异，形成陀螺仪般动态光环
2. **符文光环**：每 2 tick 在赤道平面生成旋转六边形 `ENCHANTED_HIT` 粒子阵列
3. **能量汇聚脉冲**：每 80 tick 触发一次，从半径 1.2 格外向球心飞射 `END_ROD` 粒子流
4. **顶部能量喷射**：每 5 tick 从球体顶部释放缓慢上升的 `END_ROD` 微光
5. **底部逆门涟漪**：每 3 tick 在底部生成向下扩散的 `REVERSE_PORTAL` 紫色粒子

---

### 3. 编程式 UV 球体渲染器（SpaceBallEntityRenderer）

使用 MC 1.21.11 的 `OrderedRenderCommandQueue.submitCustom` API 绘制高精度球面网格，替代传统 ModelPart 方块堆叠方式。

**球体网格**：
- 通过三角函数参数化生成（球坐标 φ/θ），32 扇区 × 16 层叠 = 512 个四边面
- 初始化时预计算顶点数据（位置、法线、UV），每帧零分配复用

**双层渲染**：

| 层级 | 渲染层 | 半径 | 颜色 (RGBA) | 光照 |
|------|--------|------|-------------|------|
| 内层核心 | `entitySolid` | 0.56 格 | (235, 240, 255, 255) 微蓝白 | 环境光照 |
| 外层光晕 | `entityTranslucentEmissive` | 0.70 格 | (245, 248, 255, 100) 半透明 | 全亮自发光 |

**动画效果**：
- Y 轴旋转：1.5°/tick（约 12 秒一圈）
- 正弦浮动：振幅 0.15 格，周期 3 秒（ω = 2π/60 ≈ 0.10472 rad/tick）

**发光轮廓（Outline）支持**：

`submitCustom` 产生的 `CustomCommand` 不包含 `outlineColor` 字段，且 `CustomCommandRenderer` 不接收 `OutlineVertexConsumerProvider`，因此无法直接产生透视轮廓。

解决方案：通过 `submitModel` 额外提交一个球形近似模型（5 个不同朝向的立方体联合），利用 `ModelCommand` 的 `outlineColor` 字段触发轮廓帧缓冲写入。

| 参数 | 值 | 说明 |
|------|-----|------|
| OUTLINE_RADIUS | 1.80 格 | 轮廓球体近似半径 |
| OUTLINE_CUBE_HALF_SIDE | 1.04 格 | = OUTLINE_RADIUS / √3 |
| 立方体数量 | 5 个 | 基础 + 绕 Y/X/Z 各旋转 45° + 绕 XY 旋转 45° |

渲染顺序利用：`RenderDispatcher` 中 `ModelCommandRenderer` 先于 `CustomCommandRenderer` 执行，立方体模型先写入深度缓冲和轮廓帧缓冲，球体随后通过深度测试覆盖大部分立方体区域。轮廓帧缓冲独立于主深度缓冲，保留球形近似轮廓。

---

### 4. 物品模型回撤

空间球物品模型（`models/item/space_ball.json`）从之前的 3D 球体模型恢复为标准平面精灵图（`minecraft:item/generated`），确保物品栏、手持和普通丢弃时显示为 2D 贴图。3D 渲染仅用于死亡掉落的自定义实体。

---

### 5. 清理 ItemEntityAccessor Mixin

玩家死亡掉落改用 `SpaceBallEntity` 后，不再需要通过 `ItemEntityAccessor` 访问 `ItemEntity.itemAge` 来设置永不消失。已从 `minddomain.mixins.json` 和源码中移除：

- 删除 `src/main/java/org/mo/minddomain/mixin/ItemEntityAccessor.java`
- 从 `minddomain.mixins.json` 的 `mixins` 数组中移除 `"ItemEntityAccessor"`

---

## 新增文件

| 文件 | 说明 |
|------|------|
| `entity/ModEntities.kt` | 实体类型注册模块（`SPACE_BALL_ENTITY`，SpawnGroup.MISC，0.5×0.5 碰撞箱，trackingTickInterval=20） |
| `entity/SpaceBallEntity.kt` | 空间球自定义实体（重力、交互、粒子、持久化，约 380 行） |
| `client/render/SpaceBallEntityRenderer.kt` | 编程式 UV 球体渲染器 + 球形近似轮廓模型（约 380 行） |
| `textures/entity/space_ball_sphere.png` | 球体表面纹理（纯白，颜色通过顶点着色控制） |

## 变更文件

| 文件 | 变更内容 |
|------|----------|
| `icon.png` | 替换为新设计的模组 Logo |
| `Minddomain.kt` | `onInitialize()` 中新增 `ModEntities.register()` |
| `MinddomainClient.kt` | `onInitializeClient()` 中注册 `SpaceBallEntityRenderer` |
| `event/ModEvents.kt` | `handlePlayerDeath()` 改用 `SpaceBallEntity.spawn()` 替代 `dropStack()` + `ItemEntityAccessor` |
| `models/item/space_ball.json` | 从 3D 球体模型回撤为 `minecraft:item/generated` 平面精灵图 |
| `minddomain.mixins.json` | 移除 `ItemEntityAccessor` |
| `lang/zh_cn.json` | 新增 `entity.minddomain.space_ball_entity` |
| `lang/en_us.json` | 新增 `entity.minddomain.space_ball_entity` |
| `gradle.properties` | `mod_version` 1.2.1-SNAPSHOT → 1.3.0-SNAPSHOT |

## 技术决策记录

### 为什么不使用 ModelPart 方块堆叠渲染球体？

MC 的 `ModelPart` 仅支持轴对齐长方体（Cuboid），无法表达曲面。通过堆叠大量微小立方体近似球面会产生明显的阶梯状棱角，用户评价"球体不够圆"。最终采用编程式三角函数生成 UV 球面网格，通过 `submitCustom` 直接向 `VertexConsumer` 提交自定义顶点数据。

### 为什么浮动动画在渲染器而非实体 tick() 中实现？

`SpaceBallEntity` 使用 `trackingTickInterval(20)`（每秒同步一次位置）以减少网络流量。如果在 `tick()` 中修改实体位置实现浮动，20 tick 的同步间隔会导致客户端位置插值产生明显跳动。将浮动纯粹作为渲染器视觉偏移（`matrices.translate`）不修改实体实际坐标，避免了同步延迟问题。

### 为什么使用 submitModel 立方体实现轮廓而非 submitCustom？

MC 1.21.11 的渲染命令队列中：
- `CustomCommand`（`submitCustom` 产生）**没有** `outlineColor` 字段
- `CustomCommandRenderer` **不接收** `OutlineVertexConsumerProvider`
- `ModelCommand`（`submitModel` 产生）**有** `outlineColor` 字段
- `ModelCommandRenderer` **接收** `OutlineVertexConsumerProvider` 并处理轮廓写入

因此 `submitCustom` 渲染的几何体无法产生透视轮廓，必须通过 `submitModel` 提交带 `outlineColor` 的模型。轮廓模型使用 5 个不同朝向的立方体联合近似球形轮廓。

## 已知问题

- 轮廓模型半径（1.80 格）大于外层球体半径（0.70 格），立方体顶点区域在直视时可能产生微小的白色渲染瑕疵
- 轮廓形状为多面体近似球形（5 个旋转立方体联合），非完美圆形
